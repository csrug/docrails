h2. Začínáme s Rails

Tento průvodce vám pomůže začít s Ruby on Rails. Až si jej přečtete, bude vám jasnější:

* Instalace Rails, vytvoření nové Rails aplikace a propojení aplikace s databází
* Obecná struktura Rails aplikace
* Základní principy MVC (Model, View, Controller) a designu založeného na architektuře REST
* Generování základních stavebních kamenů Rails aplikace

endprologue.

WARNING. Tento průvodce popisuje Rails ve verzi 3.0. Některé části kódu zde uvedené nebudou fungovat v předchozích verzích.

h3. Předpoklady

Tento průvodce je zamýšlen pro začátečníky, kteří chtějí začít s Rails aplikací od úplného začátku. Nepředpokládá žádnou předchozí zkušenost s Rails. Abyste z něj ale vytěžili co nejvíce, měli byste si nainstalovat následující:

* Jazyk "Ruby":http://www.ruby-lang.org/en/downloads ve verzi 1.8.7 nebo 1.9.2
* Balíčkovací systém "RubyGems":http://rubyforge.org/frs/?group_id=126
* Funkční instalaci databáze "SQLite3":http://www.sqlite.org

Rails je framework pro tvorbu webových aplikací, využívající programovací jazyk Ruby. Pokud nemáte žádnou předchozí zkušenost s Ruby, může pro vás být náročné pustit se rovnou do Rails. Na webu je k dispozici mnoho volně dostupných zdrojů v angličtině, mimojiné:

* "Ruby in Twenty Minutes":http://www.ruby-lang.org/en/documentation/quickstart/
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Rails for PHP Developers":http://railsforphp.com/reference

Volně dostupné i placené zdroje v češtině jsou zastaralé nebo neadekvátní. Částečnou výjimku tvoří kniha "_Ruby - kompendium znalostí pro začátečníky i profesionály_":http://www.zonerpress.cz/kniha/pro-programatory/ruby-kompendium-znalosti-pro-zacatecniky-i-profesionaly od nakladatelství Zoner Press.

h3. Co jsou Rails?

Ruby On Rails je framework pro vývoj webových aplikací napsaný v jazyce Ruby. Je navržen tak, aby usnadnil programování webových aplikací na základě obecných předpokladů vývoje pro web. Umožňuje vám psát méně kódu a zároveň dosáhnout více než v mnoha jiných jazycích a platformách. Pokročilejší Rails vývojáři také často říkají, že programovat webové aplikace v Rails je mnohem zábavnější.

Rails jsou docela „umíněný“ software. Mají za to, že existuje něco jako „nejlepší přístup“ a snaží se k tomuto přístupu své uživatele vést — ba je v některých případech od jiných přístupů i odrazovat. Pokud si tento „Rails přístup“ osvojíte, pravděpodobně zjistíte, že jste mnohem produktivnější. Pokud budete trvat na starých návycích získaných v jiných jazycích nebo platformách, a budete se tyto způsoby snažit přenést do vývoje v Rails, programování vás asi tolik bavit nebude.

Filosofie Rails obsahuje několik vůdčích principů:

* DRY — „Don't repeat yourself“ aneb „neopakujte se“ — znamená, že psát stejný kód stále dokola je špatné a dobrý kód je „znovupoužitelný“
* Konvence má přednost před konfigurací — znamená, že Rails předpokládají co asi chcete udělat a jak to chcete udělat, místo aby vás nutily specifikovat každou drobnost v nekonečném množství konfiguračních souborů
* REST je nejlepší architektonický vzor pro webové aplikace — znamená, že uspořádat webovou aplikaci jako soubor „zdrojů“ (_resources_) a standardních HTTP „sloves“ (_verbs_) je nejsnazší a nejrychlejší způsob, jak modelovat entity a jejich vztahy

h4. Architektura MVC

Ruby on Rails obsahují ve svém jádru architekturu Model, View, Controller, obvykle označovanou jako MVC. Mezi výhody MVC patří:

* oddělení aplikační logiky od uživatelského rozhraní
* znovupoužitelnost kódu
* přehledná struktura kódu aplikace, která usnadňuje údržbu

h5. Modely (_models_)

Model reprezentuje informace (data) ve vaší aplikaci a pravidla pro práci s nimi. V případě Rails jsou modely primárně využívány pro interakci s příslušnou tabulkou v databázi a pro ukládání pravidel této interakce. Ve většině případů odpovídá jedna tabulka v databázi jednomu modelu ve vaší aplikaci. Modely obsahují většinu aplikační logiky.

h5. Pohledy (_views_)

Pohledy, neboli anglicky _views_ reprezentují uživatelské rozhraní vaší aplikace. V Rails jsou _views_ obvykle HTML soubory s vloženými částmi Ruby kódu, který provádí pouze úkony týkající se prezentace dat. _Views_ mají na starosti poskytování dat webovému prohlížeči nebo jinému nástroji, který zasílá vaší aplikaci požadavky.

h5. Kontrollery (_controllers_)

Kontrollery fungují jako „lepidlo“ mezi modely a _views_. V Rails slouží kontrollery k zpracování požadavků které přichází z webového prohlížeče, získávání dat z modelů a k odesílání těchto dat do _views_, kde budou zobrazeny.

h4. Součásti Rails

Rails nejsou monolitický framework, ale jsou poskládány z mnoha dílčích součástí:

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties

Následující kapitoly stručně popisují jejich úlohu.

h5. Action Pack

Action Pack je gem, který obsahuje Action Controller, Action Dispatch a Action View. Je to „VC“ část z MVC.

h5. Action Controller

Action Controller je komponenta, která má na starosti kontrollery v Rails aplikaci. Zpracovává příchozí požadavky, extrahuje z nich parametry a směruje je na příslušnou „akci“ v příslušném kontrolleru. Poskytuje podporu pro _sessions_, renderování šablon a přesměrování.

h5. Action View

Action View má na starosti views ve vaší aplikaci. Ve výchozím nastavení umí poskytovat výstup v HTML a XML. Řídí renderování šablon, včetně šablon vnořených a parciálních, a obsahuje zabudovanou podporu pro Ajax.

h5. Action Dispatch

Action Dispatch zpracovává směrování příchozích požadavků a posílá je tam, kam chcete: buď do vaší aplikace, nebo jakékoliv jiné Rack aplikace.

h5. Action Mailer

Action Mailer poskytuje podporu pro práci s e-maily. Umožňuje rozesílat e-maily v _plaintextu_ nebo formátované _multipart_ e-maily s přílohami, a to na základě flexibilních šablon. Umožňuje vám ale také e-maily přijímat a zpracovávat.

h5. Active Model

Active Model definuje rozhraní mezi službami součástí Action Pack a vrstvami tzv. ORM (_Object Relational Mapping_, objektově relační mapování). Jednou z takových vrstev je i Active Record. Active Model umožňuje v Rails používat jiné ORM technologie pro práci s relační databází (např. DataMapper), ale rovněž nerelační databáze jako MongoDB nebo CouchDB.

h5. Active Record

Active Record je základem pro modely v Rails aplikaci. Poskytuje mimo jiné nezávislost na SQL dialektu konkrétní databáze, základní operace pro získávání, vytváření, editaci a mazání záznamů (tzv. CRUD, _Create Read Update Delete_), pokročilé získávání dat z databáze (operace typu JOIN, GROUP, aj.) a v neposlední řadě i možnost definovat vztahy mezi jednotlivými modely.

h5. Active Resource

Active Resource umožňuje propojit modely ve vaší aplikaci s webovou službou typu REST. Mapuje modely na vzdálené webové služby  umožňuje vám s nimi pracovat podobně jako by byly mapovány na databázi.

h5. Active Support

Active Support je rozsáhlý soubor podpůrných funkcí a rozšíření základních tříd Ruby, které kromě kódu samotných Rails může využít i vaše aplikace.

h5. Railties

Railties jsou jádrem kódu Ruby On Rails, který umožňuje vygenerovat novou Rails aplikaci a propojuje jednotlivé frameworky a součásti dohromady.

h4. REST

REST je zkratka pro _Representational State Transfer_ a je základem tzv. REST architektury. Za její manifest je obecně považována disertační práce Roye Fieldinga, "Architectural Styles and the Design of Network-based Software Architectures":http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm. Nemusíte ji číst celou — v Rails se REST architektura projevuje v podstatě těmito způsoby:

* vaši aplikaci tvoří určité *entity* („zdroje“), které lze jednoznačně identifikovat, typicky prostřednictvím jejich URL
* vaše aplikace přenáší *reprezentace* stavu těchto entit mezi jednotlivými součástmi celého systému

Uveďme příklad. V Rails aplikaci bude tento požadavek:

<tt>DELETE /photos/17</tt>

interpretován jako *odkaz* na určitou entitu, v tomto případě _fotografii_, která má ID 17 a jako *pokyn* k určité akci: smazání této entity, tedy fotografie. Pro webové aplikace je REST zcela přirozená architektura, a Rails ji implementují takovým způsobem, že nemusíte vědět o mnoha komplexních problémech s ní spjatých, nebo s podivnou implementací HTTP v prohlížečích (např. to, že neznají HTTP metodu DELETE).


Pokud by vás zajímalo více podrobností o REST jako architektonickém stylu, následující zdroje jsou stravitelnější než Fieldingova disertace:

* "A Brief Introduction to REST [anglicky]":http://www.infoq.com/articles/rest-introduction od Stefana Tilkova
* "An Introduction to REST [anglicky]":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) od Joe Gregoria
* "Representational State Transfer [anglicky]":http://en.wikipedia.org/wiki/Representational_State_Transfer článek na Wikipedii
* "How to GET a Cup of Coffee [anglicky]":http://www.infoq.com/articles/webber-rest-workflow od Jima Webbera, Savase Parastatidise & Iana Robinsona

h3. Vytvoření nové Rails aplikace

V průběhu tohoto návodu společně vytvoříme kompletní Rails aplikaci, velmi jednoduchý weblog, nazvaný prostě: <tt>blog</tt>. Předtím než začneme se samotnou aplikací se ale musíme ujistit, že máte Rails správně nainstalované.

h4. Instalace Rails

Ve většině je nejjednodušší nainstalovat Ruby On Rails pomocí balíčkovacího systému RubyGems:

<shell>
# Je možné, že tento příkaz budete muset spustit pomocí <tt>sudo</tt> jako _root_ uživatel
$ gem install rails
</shell>

TIP. Pokud pracujete na Windows, mějte na paměti, že drtivá většina Rails vývojářů používá systémy na bázi Unixu. I když samotné Ruby a Rails lze na Windows snadno nainstalovat například pomocí "Ruby Installer":http://rubyinstaller.org/, mnoho Ruby gemů předpokládá, že na vaší platformě lze zkompilovat kód v jazyce C a že umíte pracovat v příkazové řádce. Pokud je to pro vás jen trochu schůdné, doporučujeme vám nainstalovat si virtuální stroj s operačním systémem Linux a vyvíjet Rails aplikace v něm, místo na Windows.

h4. Vytvoření aplikace

Pokud chcete mít z tohoto návodu skutečný užitek, postupujte doslova krok za krokem. Nevynechali jsme žádný krok ani kousek kódu. Pokud si chcete prohlédnout celý kód, můžete si jej stáhnout z "Githubu":http://github.com/mikel/getting-started-code.

Nejprve si otevřete terminál a napište:

<shell>
$ rails new blog
</shell>

Tento příkaz vytvoří novou aplikaci nazvanou Blog ve složce s názvem <tt>blog</tt>.

TIP: Různé parametry, které můžete využít při generování Rails aplikací, si můžete vypsat příkazem <tt>rails new -h</tt>.

Poté aplikaci vygenerujte, přepněte se do jejího adresáře:

<shell>
$ cd blog
</shell>

Vidímě, že Rails generátor vytvořil v aktuálním adresáři složku pojmenovanou <tt>blog</tt>. Otevřete ji a prozkoumejte její obsah. V tomto návodu budeme většinou pracovat ve složce <tt>app/</tt>, ale zde je základní popis toho, co se skrývá v dalších složkách, které generátor s novou aplikací vytvoří.

|_.Soubor/Složka|_.Účel|
|Gemfile|Specifikace gemů (a případně jejich verzí), které vaše aplikace vyžaduje.|
|README.rdoc|Návod k aplikaci. Zde popište, co vaše aplikace dělá, jak ji nainstalovat, nastavit, apod. Slouží též jako úvodní stránka vygenerované dokumentace (viz příkaz <tt>rake doc:app</tt>).|
|Rakefile|Natahuje definice konzolových příkazů pro nástroj <tt>Rake</tt> (definované v Rails a ve vaší aplikaci).|
|app/|Obsahuje kontrolery (_controllers_), modely (_models_) a pohledy (_views_).|
|config/|Konfigurace aplikace, směrování požadavků (<tt>routes.rb</tt>), definice přístupových údajů k databázi a podobně.|
|config.ru|Konfigurace pro spuštění aplikace prostřednictvím webových serverů využívajících rozhraní Rack.|
|db/|Aktuální schéma databáze a databázové migrace.|
|doc/|Podrobná dokumentace pro vaši aplikaci.|
|lib/|Rozšíření a doplňkové soubory vyžadované vaší aplikací.|
|log/|Logy aplikace.|
|public/|Jediná složka, která je přístupná přes web. Obsahuje obrázky, JavaScript, stylové předpisy (CSS) a další statické soubory.|
|script/|Obsahuje skript <tt>rails</tt>, který spouští vaši aplikaci ve vývojovém prostředí, generuje kód, spouští interaktivní konzoli aplikace, a podobně.|
|test/|Jednotkové a funkční testy, testovací data a ostatní nástroje pro automatizované testování aplikace. Ty jsou popsány v návodu "Testing Rails Applications":testing.html|
|tmp/|Dočasné soubory|
|vendor/|Místo pro zdrojové soubory třetích stran. V typické Rails aplikaci jsou to například gemy a pluginy rozšiřující funkce Rails, případně též zdrojový kód Rails.|

h4. Instalování potřebných Gemů

Rails aplikace definuje gemy, které vyžaduje pro svůj běh pomocí nástroje "Bundler":http://gembundler.com/. Protože si vystačíme s těmi gemy, které jsou specifikovány ve vygenerovaném +Gemfile+, můžeme přímo spustit příkaz:

<shell>
bundle install
</shell>

abychom je nainstalovali.

h4. Konfigurace databáze

Skoro všechny Rails aplikace komunikují s databází (i když to není žádnou podmínkou). To, jakou databázi Rails použijí, je nastaveno v konfiguračním souboru, +config/database.yml+. Pokud tento soubor otevřete, uvidíte výchozí konfiguraci používající SQLite3. Důležité je to, že konfigurace je od začátku nastavena pro tři různá prostředí, v nichž může být Rails aplikace spuštěna:

* Vývojové prostředí (+development+) používáme na svém počítači, když aplikaci vyvíjíme a pracujeme s ní.
* Testovací prostředí (+test+) používají automatizované testy.
* Produkční prostředí (+production)+ je používáno na serveru, kam svoji aplikaci nainstalujeme, abychom ji zpřístupnili ostatním.

h5. Konfigurace databáze SQLite3

Rails obsahují zabudovanou podporu pro "SQLite3":http://www.sqlite.org, což je jednoduchá databáze, která nepotřebuje server. Je možné (i když nijak nutné), že produkční provoz by ji přetížil, ale na vývoj a testování je ideální. Když Rails vytvářejí novou aplikaci, automaticky vytvářejí konfiguraci pro SQLite3 — to ale můžete kdykoliv změnit.

Takto vypadá konfigurace pro připojení k databázi ve vývojovém prostředí ve výchozím souboru <tt>config/database.yml</tt>:

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: V tomto návodu používáme pro ukládání dat SQLite3, jelikož nepotřebuje žádnou konfiguraci a „prostě funguje“. Rails samotné podporují rovněž MySQL and PostgreSQL a existují pluginy pro mnoho ostatních databázových systému. Pokud používáte v produkčním prostředí nějakou konkrétní databázi, je velmi pravděpodobné, že pro ni bude k dispozici ten správný adaptér, abyste ji mohli používat v Rails.

h5. Konfigurace databáze MySQL

Pokud chcete místo výchozí databáze SQLite3 použít MySQL, váš +config/database.yml+ bude vypadat trochu jinak. Zde je konfigurace pro vývojové prostředí:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Pokud máte na vašem vývojovém počítači instalaci MySQL s uživatelem root a prázdným heslem, konfigurace bude fungovat. V opačném případě změnte uživatelské jméno a heslo.

h5. Konfigurace databáze PostgreSQL

A konečně, pokud budete chtít použít PostgreSQL, váš +config/database.yml+ bude vypadat nějak takto:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

Je pravděpodobné, že budete muset změnit jméno a heslo.

TIP: Konfiguraci databáze nemusíte zapisovat ručně. Pokud jste se podívali na volby generátoru nové aplikace, jistě jste přišli na to, že obsahuje volbu <tt>--database</tt>. Dává vám na výběr z adaptérů pro několik nejrozšířenějších relačních databází. Generátor můžete spustit i opakovaně: <tt>cd .. && rails new blog --database=mysql</tt>. Potvrďte přepsání souboru +config/database.yml+ a aplikace bude nakonfigurována pro databázi MySQL.

h4. Vytvoření databáze

Když máme konfiguraci databáze hotovou, pojďme ji vytvořit. Toho dosáhnete spuštěním příkazu:

<shell>
$ rake db:create
</shell>

Ten vytvoří databáze SQLite3 pro vývojové a testovací prostředí v adresáři <tt>db/</tt>.

TIP: Rake je obecným nástrojem pro spouštění konzolových příkazů, který Rails používají na mnoho různých věcí. Seznam dostupných  příkazů si zobrazíte spuštěním příkazu +rake -T+.

h3. Ahoj Rails!

Jedním z tradičních způsobů, ja začít s novým programovacím jazykem je zobrazení krátkého textu na obrazovce. Abyste toho docílili, musíte spustit server Rails aplikace.

h4. Spuštění webového serveru

Ve skutečnosti už máte připravenou plně funkční Rails aplikaci. Abyste si ji zobrazili, musíte spustit webový server na vašem vývojovém počítači. Uděláte to následujícím příkazem:

<shell>
$ rails server
</shell>

Ve výchozím nastavení se spustí instance web serveru Mongrel (Rails mohou použít řadu jiných webových serverů). Pro zobrazení aplikace otevřete okno vášeho prohlížeče a jděte na stránku "http://localhost:3000":http://localhost:3000. Měli byste vidět základní informační stránku Rails:

!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: Pro zastavení serveru zmáčkněte Ctrl+C v terminálovém okně, kde server běží. V development módu Rails obvykle nevyžadují zastavení serveru. Jakékoliv změny v souborech, které provedete, server automaticky načte.

Stránka "Welcome Aboard" je jen _zkouška sirén_ pro novou Rails aplikaci: ujišťuje se, že máte vše správně nastaveno pro zobrazení stránky. Můžete táké přejít na odkaz _About your application's environment_ kde najdete shrnutí konfigurace vašeho aplikačního prostředí.

h4. Rails, řekněte "Ahoj"

Aby Rails řekly "Ahoj", musíte vytvořit kontroler (controller) a pohled (view). Naštěstí toto můžete provést spuštěním jediného příkazu. Vložte tedy do terminálu:

<shell>
$ rails generate controller home index
</shell>

TIP: Pokud používáte Windows, nebo máte Ruby nestandardně nainstalované, možná budete muset příkaz pustit s celou cestou k Rails: +ruby \path\to\rails controller home index+.

Rails pro Vás vytvoří několik souborů, včetně +app/views/home/index.html.erb+. Toto je šablona, která bude použita pro zobrazení výsledku akce (action) index v kontroleru (controller) home. Otevřete tento soubor v textovém editoru a upravte ho, aby obsahoval tuto jednoduchou řádku kódu:

<code class="html">
<h1>Ahoj Rails!</h1>
</code>

h4. Nastavení domovské stránky aplikace

Nyní, když jsme vytvořili controller a view, ještě potřebujeme Rails říci, kdy se má "Ahoj, Rails" zobrazit. V našem případě chceme, aby se to zobrazilo na výchozí URL naší stránky, "http://localhost:3000":http://localhost:3000, namísto zkušební stránky "Welcome Aboard".

Prvním krokem je smazání základní stránky z vaší aplikace:

<shell>
$ rm public/index.html
</shell>

Toto musíme udělat, jelikož Rails posílají jakýkoli statický obsah ze složky +public+ přednostně před dynamicky generovaným obsahem z controllerů.

Nyní musíte Rails říci, kde se nachází skutečná domovská stránka. Otevřete soubor +config/routes.rb+ v textovém editoru. To je konfigurace cest (routes) aplikace, které jsou nastaveny speciálním DSL (domain-specific language). Díky tomu Rails ví, jak spojit příchozí požadavky s controllery a akcemi. Tento soubor obsahuje mnoho příkladů v zakomentovaných řádcích. Jeden z nich ukazuje, jak spojit domovskou stránku vaší aplikace s konkrétním controllerem a akcí. Najděte řádek začínající na +root :to+, odkomentujte ho a změňte následovně:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

The +root :to => "home#index"+ říká Rails, že má požadavky směřované na "/" spojit s controllerem home a jeho akcí index.

Pokud si nyní v prohlížeči zobrazíte "http://localhost:3000":http://localhost:3000, uvidíte +Ahoj, Rails!+.

NOTE. Více informací ohledně routování naleznete v "Rails Routing from the Outside In":routing.html.

h3. Rychlý start s použitím nástroje Scaffolding (lešení)

V Rails je _scaffolding_ rychlým způsobem jak vytvořit některé hlavní kusy aplikace. Když chcete vytvořit modely, views a controllery pro nové zdroje v jediném kroku, scaffolding je tím správným nástrojem.

h3. Vytvoření zdroje

V případě blogovací aplikace můžete začít vytvořením scaffold pro zdroj Post (příspěvek): ten bude představovat jednotlivý příspěvek na blogu. Pro jeho vytvoření zadejte v terminálu následující příkaz:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOTE. I když Vám scaffolding pomůže rychle začít, univerzální kód, který vygeneruje, pravděpodobně nebude perfektně vyhovovat Vaší aplikaci. Ve většině případů budete chtít následně poupravit vygenerovaný kód. Mnoho zkušených vývojářů v Rails vůbec scaffolding nepoužívá a upřednostňuje psaní veškerého nebo většiny kódu „z čistého listu.“

Scaffolding generátor vytvoří ve Vaší aplikaci 15 souborů, několik složek, a jeden soubor upraví. Toto je přehled co všechno vytvoří:

|_.Soubor                                       |_.Účel|
|db/migrate/20100207214725_create_posts.rb.rb    |Migrace vytvářející tabulku posts v databázi (u Vás bude název obsahovat jinou časovou značku)|
|app/models/post.rb                           |model Post|
|test/fixtures/posts.yml                      |Uměle vygenerované příspěvky pro účely testování|
|app/controllers/posts_controller.rb          |Posts controller|
|app/views/posts/index.html.erb               |View zobrazující seznam všech příspěvků|
|app/views/posts/edit.html.erb                |View k úpravám existujícího příspěvku|
|app/views/posts/show.html.erb                |View pro zobrazení jednotlivého příspěvku|
|app/views/posts/new.html.erb                 |View pro vytvoření nového příspěvku|
|app/views/posts/_form.html.erb               |Parciální šablona formuláře použitého ve views new a edit|
|app/helpers/posts_helper.rb                  |Pomocné funkce pro předchozí views|
|test/unit/post_test.rb                       |Jednotkové testy posts modelu|
|test/functional/posts_controller_test.rb     |Funkční testy posts controlleru|
|test/unit/helpers/posts_helper_test.rb       |Jednotkové testy posts helperu|
|config/routes.rb                             |Do souboru přidány údaje pro směrování posts|
|public/stylesheets/scaffold.css              |Kaskádové styly zlepšující vzhled scaffoldovaných views|

h4. Spuštění migrace

Jedním z výstupů příkazu +rails generate scaffold+ je _databázová migrace_. Migrace jsou třídy Ruby, jejichž účelem je zjednodušit vytváření nebo úpravy databázových tabulek. Rails používají ke spuštění migrací příkaz rake, a je také možné vrátit zpět migraci, která již byla provedena. Názvy souborů migrací obsahují časovou značku, aby bylo zajištěno, že jsou zpracovány v pořadí, v jakém byly vytvořeny.

Když se podíváte do souboru +db/migrate/20100207214725_create_posts.rb+ (pamatujte, že Váš bude mít mírně odlišný název), uvidíte následující:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

Tato migrace vytváří dvě metody: +up+, volanou když spustíte tuto migraci nad databází, a +down+ v případě, že chcete později vrátit změny, provedené touto migrací na databázi. V tomto případě medtoda +up+ vytvoří tabulku +posts+ se dvěma sloupci formátu string (textový řetězec) a jeden sloupec formátu text. Také vytvoří dva sloupce pro časové značky určené pro zachycení vyvoření a editace záznamu. Více informací o migracích naleznete v průvodci "Rails Database Migrations":migrations.html.

Nyní můžete použít příkaz rake ke spuštění migrace:

<shell>
$ rake db:migrate
</shell>

Rails provede migraci a oznámí Vám, že vytvořily tabulku Posts.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. Protože pracujete implicitně v development prostředí, tento příkaz se provede nad databází definovanou v sekci +development+ v souboru +config/database.yml+.

h4. Přidání odkazu

K napojení příspěvků na domácí stránku, kterou jste už vytvořili, můžete přidat odkaz. Otevřete +app/views/home/index.html.erb+ a změňte jej takto:

<code lang="ruby">
<h1>Ahoj, Rails!</h1>
<%= link_to "Můj blog", posts_path %>
</code>

Metoda +link_to+ je jednou z pomocných funkcí views, zabudovaných v Rails. Vytvoří hypertextový odkaz z parametrů jaký text zobrazit a kam odkázat – v tomto případě cesta k příspěvkům.

h4. Práce s příspěvky v prohlížeči

Nyní už můžete začít pracovat s příspěvky. Přejděte na "http://localhost:3000":http://localhost:3000/ a klikněte na odkaz "Můj blog":

!images/posts_index.png(Posts Index screenshot)!

Toto je výsledkem vykreslení pohledu +index+. Momentálně nejsou v databázi žádné příspěvky, ale pokud kliknete na odkaz +New Post+, můžete nějaký vytvořit. Následně uvidíte, že můžete příspěvky editovat, podívat se na jejich detaily nebo je mazat. Veškerá tato aplikační logika a HTML, které se o to starají, byly vytvořeny jediným příkazem +rails generate scaffold+.

TIP: V módu development (ve kterém pracujete implicitně) Rails znovu načítá celou aplikaci při každém požadavku odeslaném prohlížečem, takže není třeba restartovat webserver.

Gratulujeme, jedete na Rails! Teď je na čase podívat se, jak to všechno funguje.

h4. Model

Soubor modelu +app/models/post.rb+ už snad nemůže být jednodušší:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

K tomu není moc co dodat - ale povšimněte si prosím, že třída +Post+ dědí od třídy +ActiveRecord::Base+. Active Record poskytuje spoustu funkcionality Vašim rails modelům zdarma, včetně základních databázových operací CRUD (Create/Vytvořit, Read/Načíst, Update/Upravit, Destroy/Odstranit), validací dat, a také sofistikovanou podporu vyhledávání a schopnost vytváření relací mezi jednotlivými modely.

h4. Přidání pár validací

Rails obsahují metody, které Vám pomůžou validovat data, která se posílají modelu. Otevřete soubor +app/models/post.rb+ a upravte jej:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

Tyto změny zajistí, že všechny příspěvky budou mít jméno (name) a titulek (title) a že titulek bude mít alespoň 5 znaků. Rails můžou validovat mnoho různých podmínek v modelu, včetně existence a unikátnosti sloupců, jejich formátu a existence asociovaných objektů.

h4. Použití konzole

Abychom si prohlídli validace v akci, můžeme použít konzoli. Konzole je nástroj příkazové řádky, který umožňuje spouštět Ruby kód v kontextu Vaší aplikace:

<shell>
$ rails console
</shell>

Když se konzole načte, můžete ji použít pro práci s modely ve Vaší aplikaci:

<shell>
>> p = Post.new(:content => "Nový příspěvek")
=> #<Post id: nil, name: nil, title: nil,
     content: "Nový příspěvek", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

Tento kód ukazuje vytvoření nové instance třídy +Post+, pokus o její uložení a obdržení návratové hodnoty +false+ (indikující, že uložení se nezdařilo) a vypsání detailu chyby.

Až budete hotovi, napište +exit+ a stiskněte +enter+ pro odchod z konzole.

TIP: Narozdíl od development web serveru, konzole nenačítá znovu kód pro každý řádek. Pokud provedete změnu v modelu zatímco konzole je otevřená, napište v konzoli +reload!+, abyste tyto změny načetli.

h4. Vypsání všech příspěvků

Nejjednodušejší místo, kde začít zkoumat funkcionalitu naší aplikace je kód, který vypíše všechny příspěvky. Otevřete soubor +app/controllers/posts_controller.rb+ a podívejte se na akci +index+:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</ruby>

+Post.all+ říká modelu +Post+, aby vrátil všechny příspěvky, které momentálně v databázi jsou. Výstupem tohoto příkazu je pole s příspěvky, které uložíme do instanční proměnné nazvané +@posts+.

TIP: Více informací o vyhledávání záznamů pomocí Active Record naleznete v průvodci "Active Record Query Interface":active_record_querying.html.

Blok +repond_to+ zpracuje HTML a XML volání této akce. Pokud přejdete na "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml, uvidíte všechny příspěvky v XML formátu. Formát HTML vyhledá view ve složce +app/views/posts/+ s názvem odpovídajícím názvu akce. Rails dají všechny instanční proměnné z akce k dispozici příslušnému view. Zde je +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

Tento pohled projde obsah pole +@posts+, aby zobrazil obsah a odkazy. Několik věcí k povšimnutí v tomto view:

* +link_to+ vytvoří hypertextový odkaz na příslušný cíl
* +edit_post_path+ a +new_post_path+ jsou helpery, které Rails poskytují jako součást REST směrování. U dalších akcí, které controller obsahuje, uvidíte mnoho dalších variací těchto helperů.

NOTE. V předchozích verzích Rails jste museli použít +&lt;%=h post.name %&gt;+ aby bylo případný HTML kód transformován, než bude vložen do stránky. V Rails 3.0 je tato operace implicitní. Abyste získali netransformované HTML, použijte +&lt;%= raw post.name %&gt;+.

TIP: Více detailů k zobrazovacímu procesu najdete v průvodci "Layouts and Rendering in Rails":layouts_and_rendering.html.

h4. Ůprava layoutu

View je jen část příběhu, jak je se HTML zobrazí ve Vašem prohlížeči. Rails také používají konecpt layoutů, což jsou konteinery pro views. Když Rails zobrazují view v prohlížeči, vkládají HTML kód z view souboru do HTML kódu layoutu. V předchozích verzích Rails příkaz +rails generate scaffold+ automaticky vytvořil samostatný layout pro příslušný controller, například +app/views/layouts/posts.html.erb+ pro posts controller. Tohle však bylo v Rails 3.0 změněno. Vytváří se jeden +layout+ pro celou aplikaci a je uložen jako soubor +app/views/layouts/application.html.erb+. Otevřete tento layout ve Vašem editoru a upravte tag +body+:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tag %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Když teď znovu načtete stránku +/posts+, uvidíte, že má šedé pozadí. Stejné šedé pozadí bude použito ve všech ostatních views.

h4. Vytváření nových příspěvků

Vytvoření nového příspěvku zahrnuje dvě akce. První je akce +new+, která vytvoří prázdný objekt +Post+:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

View +new.html.erb+ zobrazí uživateli tento prázdný příspěvek:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

Řádek +&lt;%= render 'form' %&gt;+ je naším úvodem do parciálních šablon v Rails (dále _partials_). Partial je útržek kódu HTML a Ruby, který může být vícenásobně použit na různých místech. V tomto případě je formulář pro vytvoření nového příspěvku prakticky totožný s formulářem pro úpravu příspěvků – oba mají textová pole pro název a titlek textarea pro obsah příspěvku s tlačítkem pro vytvoření nového příspěvku nebo úpravu stávajícího.

Když se podíváte na soubor +views/posts/_form.html.erb+, uvidíte následující:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Tento partial obdrží všechny instanční proměnné definované při volání view, takže v tomto případě controller vloží nový objekt příspěveku to proměnné +@post+ a proto je k dispozici jak ve view tak v partialu jako +@post+.

Více informací k partials najdete v průvodci "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials guide.

The +form_for+ block is used to create an HTML form. Within this block, you have access to methods to build various controls on the form. For example, +f.text_field :name+ tells Rails to create a text input on the form, and to hook it up to the +name+ attribute of the instance being displayed. You can only use these methods with attributes of the model that the form is based on (in this case +name+, +title+, and +content+). Rails uses +form_for+ in preference to having you write raw HTML because the code is more succinct, and because it explicitly ties the form to a particular model instance.

The +form_for+ block is also smart enough to work out if you are doing a _New Post_ or an _Edit Post_ action, and will set the form +action+ tags and submit button names appropriately in the HTML output.

TIP: If you need to create an HTML form that displays arbitrary fields, not tied to a model, you should use the +form_tag+ method, which provides shortcuts for building forms that are not necessarily tied to a model instance.

When the user clicks the +Create Post+ button on this form, the browser will send information back to the +create+ method of the controller (Rails knows to call the +create+ method because the form is sent with an HTTP POST request; that's one of the conventions that I mentioned earlier):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

The +create+ action instantiates a new Post object from the data supplied by the user on the form, which Rails makes available in the +params+ hash. After successfully saving the new post, +create+ returns the appropriate format that the user has requested (HTML in our case). It then redirects the user to the resulting post +show+ action and sets a notice to the user that the Post was successfully created.

If the post was not successfully saved, due to a validation error, then the controller returns the user back to the +new+ action with any error messages so that the user has the chance to fix the error and try again.

The "Post was successfully created." message is stored inside of the Rails +flash+ hash, (usually just called _the flash_) so that messages can be carried over to another action, providing the user with useful information on the status of their request. In the case of +create+, the user never actually sees any page rendered during the Post creation process, because it immediately redirects to the new Post as soon Rails saves the record. The Flash carries over a message to the next action, so that when the user is redirected back to the +show+ action, they are presented with a message saying "Post was successfully created."

h4. Showing an Individual Post

When you click the +show+ link for a post on the index page, it will bring you to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter. Here's the +show+ action:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +show+ action uses +Post.find+ to search for a single record in the database by its id value. After finding the record, Rails displays it by using +show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
<% end %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial, this time however, the form will do a PUT action to the PostsController and the submit button will display "Update Post"

Submitting the form created by this view will invoke the +update+ action within the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to the +edit+ view to correct them.

h4. Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

h3. Přidání druhého modelu

Teď, když už víte, jak model vytvořený scaffoldem vypadá, je čas přidat do aplikace druhý model. Ten bude sloužit na správu komentářů k příspěvkům na blogu.

h4. Vygenerování modelu

Modely v Rails používají název v jednotném čísle a k nim přináležíci tabulky v databáze používají pro název číslo množné. Model pro komentáře bude mít podle konvencí název Comment. I když nechcete použít všechny současti vygenerované scaffoldem, většina Rails vývojářů používa generátory pro věci jako modely a kontrolery. Pro vytvoření modelu, spusťte tenhle příkaz v konzole:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

Tenhle příkaz vygeneruje čtyři soubory:

* +app/models/comment.rb+ - Model
* +db/migrate/20100207235629_create_comments.rb+ - Migrace
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - Příprava pro testy.

Nejdřív se podívejme na +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Tohle je hodně podobné modelu +post.rb+ který jste viděli dříve. Rozdílny je řádek +belongs_to :post+, který nastaví Active Record _vazbu_. O vazbách se naučíte víc v nasledující kapitole tohoto průvodce.

Jako přídavek k modelu, Rails vytvořili i migraci, která vybuduje příslušnou databázovou tabulku:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

Řádek +t.references+ nastaví cizí klíč pro vazbu mezi těmito dvěma modely. Teď spustěte migraci:

<shell>
$ rake db:migrate
</shell>

Rails jsou dostatečně chytrý, takže spustí jenom migrace, které ještě nebyly spouštěné pro aktuální databázi, takže v tomhle případě uvidíte jenom:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Provázání modelů

Vazby v Active Record vám dovolují snadno deklarovat vztahy mezi dvěma modely. V případě komentářů a příspěvků, můžete zapsat vztah tímhle způsobem:

* Každý komentář patří jednomu příspěvku
* Jeden příspěvek může mít vícero komentářů

Ve skutečnosti, tohle je hodně podobné zápisu, který Rails používají pro deklaraci této vazby. Už jste viděli řádek kódu uvnitř modelu Comment, který udělal každý komentář patřící příspěvku::

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Budete potřebovat upravit soubor +post.rb+ abyste přidali druhou stranu vazby:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

Tyhle dvě deklarace zapnou velký kus automatického chování. Například, když máte instanční proměnnou +@post+ obsahující příspěvek, můžete jednoduše získat všechny komentáře patřící tomuto příspěvku jako pole +@post.comments+.

TIP: Pro víc informací o Active Record vazbách se podívejte na průvodce "Active Record Associations":association_basics.html.

h4. Přidání routy pro komentáře

Jako s +home+ kontrolerem, musíme přidat routu, aby Rails vědeli kam se chceme dostat pro zobrazení komentářů. Otevřete znovu soubor +config/routes.rb+ , uvidíte záznam, který byl přidán automaticky pro +posts+ scaffold generátorem, +resources :posts+, upravte ho nasledovně:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

To vytvoří +comments+ jako _vnořené zdroje_ pro +posts+. Tohle je další část zachycení hierarchického vztahu, který existuje mezi příspěvky a komentáři.

TIP: Pro víc informací o routingu se podívejte na průvodce "Rails Routing from the Outside In":routing.html.

h4. Vygenerování kontroleru

Když máme hotový model, můžeme soustředit svou pozornost na vytvoření příslušného kontroleru. Pro to máme opět k dispozici generátor:

<shell>
$ rails generate controller Comments
</shell>

To vytvoří čtyři soubory a jeden prázdny adresář:

* +app/controllers/comments_controller.rb+ - Kontroler
* +app/helpers/comments_helper.rb+ - Soubor s pomocnými metodami pro zobrazení
* +test/functional/comments_controller_test.rb+ - Funkční testy pro kontroler
* +test/unit/helpers/comments_helper_test.rb+ - Jednotkový test pro helper
* +app/views/comments/+ - Tady jsou uloženy zobrazení

Jako při jakýmkoli blogu, naši čtenáři budou chtít vytvářet jejich komentáře hned po přečtení příspěvku. Jakmile komentář přidají, budou přesměrování na zobrazení příspěvku, aby viděli jejich přidaný komentář . Kvůli tomu náš +CommentsController+ poskytuje metodu pro vytváření komentářů a mazaní komentářů, které jsou považovány za SPAM.

Nejdřív dáme dohromady šablonu pro zobrazení příspěvku (+/app/views/posts/show.html.erb+) abychom mohli přidávat komentáře:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Přidat komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpátky na příspěvky', posts_path %> |
</erb>

Tohle přidá na stránku zobrazení příspěvku formulář pro přidání nového komentáře, který zavolá +CommentsController+ +create+ akci, takže ho pojďme vytvořit:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

Uvidíte zde trochu víc komplexity v porovnání s kontrolerem pro příspěvky. To je vedlejší efekt vnoření, které jste nastavili; každý požadavek pro komentář si musí ukládat informaci o tom, ke kterému příspěvku je přiřazen, proto ta začáteční find akce na modeli Post - pro získaní příspevku.

Kromě toho, kód využíva některé metody dostupné pro vazby. Používáme metodu +create+ na +@post.comments+ pro vytvoření a uložení komentáře. To automaticky nalinkuje komentář tak, aby patřil danému příspěvku.

Jakmile jsme přidali nový komentář, pošleme uživatele zpátky na originální příspěvek použitím helpru +post_path(@post)+. Jak jsme už viděli, tohle zavolá +show+ akci na +PostsController+ který následně zobrazí šablonu +show.html.erb+. Tam chceme ten komentář zobrazit, tak to přidejme do +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Komentáře</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Komentátor:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Komentář:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Přidejte komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Úprava příspěvku', edit_post_path(@post) %> |
<%= link_to 'Zpátky na příspěvky', posts_path %> |
</erb>

Teď můžete přidávat příspěvky a komentáře do vašeho blogu mít je zobrazené na správných místech.

h3. Refactoring

Teď máme fungující články a jejich komentování. Když se ale podíváme do šablony +app/views/posts/show.html.erb+, zjistíme že kód je dlouhý a nešikovný. Můžeme použít partials (parciální/částečné šablony) k lepší čitelnosti kódu.

h4. Vykreslení parciálních kolekcí

Nejdřív vytvoříme z kódu pro zobrazování komentáře u článku parciální šablonu. Vytvoříme soubor +app/views/comments/_comment.html.erb+ a do něj vložíme nasledující kód:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Potom můžeme v šabloně +app/views/posts/show.html.erb+ udělat změny tak, aby vypadal následovně:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Jméno:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidat komentář:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once for each comment that is in the +@post.comments+ collection.  As the +render+ method iterates over the <tt>@post.comments</tt> collection, it assigns each comment to a local variable named the same as the partial, in this case +comment+ which is then available in the partial for us to show.

h4. Vykreslední partial formuláře

Pojďme také přesunout sekci „nový komentář“ do vlastního partialu. Vytvořte soubor +app/views/comments/_form.html.erb+ a do něj vložte:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <%= f.error_messages %>

  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Pak změňte +app/views/posts/show.html.erb+ do následující podoby:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Druhý render pouze definuje částečnou šablonu kterou vykreslit - <tt>comments/form</tt>. Rails jsou dost chytré na to, aby poznaly lomítko v řetězci a pochopily že chcete vykreslit šablonu <tt>_form.html.erb</tt> ze složky <tt>app/views/comments</tt>.

Objekt +@post+ je dostupný v kterékoliv parciální šabloně, protože je definován jako instanční proměnná.

h3. Mazání komentářů

Další důležitou funkcí na blogu je možnost mazat SPAMové komentáře. K tomu potřebujeme implemetovat nějaký ten odkaz ve view a +DELETE+ akci v +CommentsController+.

Nejprve tedy přidejme odkaz na smazání v +app/views/comments/_comment.html.erb+ partialu:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Kliknutí na tento nový odkaz "Destroy Comment" spustí akci <tt>DELETE /posts/:id/comments/:id</tt> v našem +CommentsController+, který pak podle ní najde komentář, který chceme vymazat, takže přidejme akci destroy do našeho controlleru:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

Akce +destroy+ najde příspěvek na který se díváme, vyhledá kometář v kolekci <tt>@post.comments</tt> a pak ho vymaže z databáze a pošle nás zpět na 'show' akci příspěvku.


h4. Mazání návazných objektů

Pokud vymažete příspěvek, pak návazné komentáře je také třeba vymazat. Jinak budou prostě jen zabírat místo v databázi. Rails vám k tomutu účelu umožňuje použít možnost +dependent+ na relaci mezi modely. Upravte Post model v +app/models/post.rb+ následovně:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Bezpečnost

Kdybyste nyní poskytli veřejný přístup ke svému blogu, kdokoliv by byl schopen přidat, upravovat a mazat příspěvky a komentáře.

Rails nabízejí velmi jednoduchý HTTP autentizační systém, který bude v této situaci hezky fungovat. Nejprve umožníme jednoduchou HTTP autentizaci v našem controlleru <tt>app/controllers/application_controller.rb</tt>:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery

  private

  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end

end
</ruby>

Můžete samozřejmě změnit uživatelské jméno a heslo na cokoliv chcete. Tuto metodu dáváme do +ApplicationController+ aby byla přístupná všem našim controllerům.

Následně potřebujeme mít v +PostsController+ nějaký způsob blokování přístupu k různým akcím pokud uživatel není autentizován. Zde můžeme použít Rails metodu <tt>before_filter</tt>, která nám umožňuje určit, že Rails musí spustit metodu a až následně povolit přístup k vyžádané akci, pokud to tato metoda povolí.

Použítí before filteru deklarujeme na začátku našeho +PostController+. V tomto případě chceme, aby byl uživatel přihlášen u každé akce, kromě +index+ a +show+, takže napíšeme:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

Také mazání komentářů chceme povolit pouze přihlášeným uživatelům, takže v +CommentsController+ napíšeme:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Nyní pokud se pokusíte vytvořit příspěvek, uvítá vás základní HTTP autentizační výzva

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. Vytváření Multi-Model Formuláře

Další vlastností průměrného blogu je možnost štítkovat příspěvky. Pro jeji implementaci potřebuje vaše aplikace spolupracovat s více objekty v jednom formuláři. Rails poskytují podporu pro vnořené formuláře.

Na ukázku přidáme podporu pro přidávání několika štítků každému příspěvku přímo ve formuláři, kde vytváříme příspěvek. Nejprve vytvořte nový model, který bude reprezentovat štítky:

<shell>
$ rails generate model tag name:string post:references
</shell>

Opět, spustěte migrace pro vytvoření tabulky v databázi:

<shell>
$ rake db:migrate
</shell>

Dále, pozměňte soubor +post.rb+ abyste vytvořili druhou stranu vazby a dali Rails věďet, (přes +accepts_nested_attributes_for+ makro) že hodláte měnit štítky přes příspěvky:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

Volba +:allow_destroy+ při deklaraci nested attribute říka Rails ať zobrazí checkbox "Odstranit" v šabloně, kterou vytvoříme za chvíli. Volba +:reject_if+ zabraňuje ukládání nových štítků, které nemají vyplněny žádne atributy.

Upravíme +views/posts/_form.html.erb+ pro zobrazení partial view pro štítky:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> zabránili tomuto příspevku, aby byl uložen:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Povšimněte si, že jsme změnili +f+ v +form_for(@post) do |f|+ na +post_form+ abychom to udělali jednodušší na porozumění.

Tenhle příklad ukazuje další možnost zobrazovacího pomocníka, díky které můžeme předat lokálni proměnnou, v tomhle případě chceme, aby lokálni proměnná v častečné šabloně +form+ odkazovala na objekt +post_form+.

Také jsme přidali <tt>@post.tags.build</tt> na vrchu formuláře, tím se ujistíme, že máme připraven nový štítek pro vyplnění jeho jména uživatelem. Jestli nevytváříte nový štítek, pak se formulář nezobrazí, ponevač neexistuje nový objekt štítku pro vytvoření.

Těď vytvořte adresáŕ <tt>app/views/tags</tt> a v něm soubor <tt>_form.html.erb</tt> který obsahuje formulář pro štítek:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Štítek:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Odstranit:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Nakonec upravíme <tt>app/views/posts/show.html.erb</tt> šablonu pro zobrazování našich štítků.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<p>
  <b>Štítky:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidejte komentář:</h2>
<%= render "comments/form" %>


<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

S těmito změnami můžete upravovat příspevky svého blogu a štítky přímo ve stejným zobrazení.


Jelikož je způsob <tt>@post.tags.map { |t| t.name }.join(", ")</tt> nešikovný, můžeme si poradit použitím helper metody.

h3. Zobrazovací Helpery

Zobrazovací helpery se nacházejí v <tt>app/helpers</tt> a poskytují malé kousky znovupoužitelného kódu pro naše pohledy. V našem případě potřebujeme metodu, která zřetězí několik objektů použitím jejich názvu a spojí je čárkami. Jelikož je tahle helper metoda použita v šablone Post show, umístnime ji do PostsHelper.

Otevřte <tt>app/helpers/posts_helper.rb</tt> a přidejte nasledovné:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

Teď můžete upravit zobrazení v <tt>app/views/posts/show.html.erb</tt> aby vypadalo takhle:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Název:</b>
  <%= @post.name %>
</p>

<p>
  <b>Titulek:</b>
  <%= @post.title %>
</p>

<p>
  <b>Obsah:</b>
  <%= @post.content %>
</p>

<p>
  <b>Štítky:</b>
  <%= join_tags(@post) %>
</p>

<h2>Komentáře</h2>
<%= render @post.comments %>

<h2>Přidat komentář:</h2>
<%= render "comments/form" %>


<%= link_to 'Upravit příspěvek', edit_post_path(@post) %> |
<%= link_to 'Zpět na příspěvky', posts_path %> |
</erb>

h3. Co dál?

Teď, když jste vytvořili svou první Rails aplikaci, nemělo by vám dělat problém vylepšit si ji a experimentovat s ní. Nemusíte však dělat všechno bez nápovědy. Když budete potřebovat pomoc ohledně vývoje v Rails, neváhejte použít tyhle zdroje:

* The "Ruby on Rails guide":index.html
* The "Ruby on Rails tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails kanál na irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails také nabízí vstavanou nápovědu, kterou si můžete vygenerovat použitím nástroje rake v příkazovém řádku:

* Spuštění +rake doc:guides+ uloží kompletní kopii Rails Guides do adresáře +doc/guides+ vaši applikace. Otevřte +doc/guides/index.html+ ve svém prohlížeči pro jeji prohlížení.
* Spuštění +rake doc:rails+ uloží kompletní kopii API dokumentace pro Rails do adresáře +doc/api+ vaši aplikace. Otevřte +doc/api/index.html+ ve svém prohlížeči pro jeji prohlížení.

h3. Vychytávky pro konfiguraci

Nejjednoduchší způsub, jak pracovat s Rails je ukládat všechna externí data ve formáte UTF-8. Jestli ne, Ruby knihovny a Rails budou často schopni konvertovat vaše nativní data do UTF-8, ale ne vždy to funguje spolehlivě, takže je lepší ujistit se, že všechna externí data jsou v UTF-8.

Jestli jste v něčem z toho udělali chybu, nejčastějsí příznak je černý diamant s otazníkem vevnitř zobrazujíci se v prohlížeči. Další častý příznak je znak jako například "Ã¼" zobrazujíci se namísto "ü". Rails dělají několik interních kroků, aby zmírnili příčiny těchto problémů, které můžou být automaticky zjištěny a opraveny. Nicméně, jestli máte data, která nejsou uložena v UTF-8, může se stát, že se objeví problémy, které nemůžou být automaticky zjištěny a opraveny v Rails.

Dva časté zdroje dat, která nejsou v UTF-8:
* Váš textový editor: Většina textových editorů (jako například TextMate), ukládá soubory
  předvoleně v UTF-8. Jestli to váš editor nedělá, může se stát, že speciální znaky, které
  použijete ve vašich šablonách (například é), se v prohlížeči zobrazí jako diamant
  s otazníkem vevnitř. To se taky týká vašich I18N překladových souború. Většina editorů,
  které neukládají předvoleně do UTF-8 (jako například některé verze Dreamwaver-u) poskytují
  způsob, jak změnit předvolené ukládání na UTF-8. Udělejte to.
* Vaše databáza. Rails implicitně konvertují data z vaši databáze při výběru/zápisu.
  Takže jestli vaše databáza nepoužívá interně UTF-8, nemusí být schopna ukládat všechny znaky,
  které uživatelé zadají. Například, jestli vaše databáza interně používa Latin-1 a uživatelé
  zadají Ruské, Hebrejské nebo Japonské znaky, data se navždy stratí v momentě, kdy se dostanou
  do databázy. Jestli to je možné, používejte UTF-8 jako interní úložiště vaši databáze.

h3. Seznam změn

"Lighthouse ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/2

* August 30, 2010: Minor editing after Rails 3 release by "Joost Baaij":http://www.spacebabies.nl
* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)
